# PLANB-RPC

## 介绍

一款基于 Vert.x + Etcd + SpringBoot 实现的高性能自定义 RPC 框架。

基于 JMH 压测在 10000 并发量下的吞吐量在 29300 上下。

----------------

### 项目实现内容

- [x] 实现基于 Vert.x 进行网络通信
- [x] 自定义消息协议，编解码器
- [x] 五种序列化算法（JDK、JSON、HESSIAN、KRYO、PROTOSTUFF）
- [x] 三种负载均衡算法（RoundRobin、Random、ConsistentHash）
- [x] 基于 Etcd 的服务注册与发现，增加服务本地缓存与监听
- [x] 集成 Spring，自定义注解提供 RPC 组件扫描、服务注册、服务消费
- [x] 集成 SpringBoot，完成自动配置
- [x] 实现自定义 SPI 机制
- [x] 10000个线程同时发起RPC调用的吞吐量在 29300 上下

----

### RPC概述

RPC 又称远程过程调用（Remote Procedure Call），用于解决分布式系统中服务之间的调用问题。通俗地讲，就是开发者能够像调用本地方法一样调用远程的服务。一个最基本的RPC框架的基本架构如下图所示：

<img src="images\RPC基本架构图.png" alt="RPC基本架构图" style="zoom: 45%;" />

RPC框架一般必须包含三个组件，分别是**客户端、服务端**以及**注册中心**，一次完整的 RPC 调用流程一般为：

1. 服务端启动服务后，将他提供的服务列表发布到注册中心（服务注册）；
2. 客户端会向注册中心订阅相关的服务地址（服务订阅）；
3. 客户端通常会利用本地代理模块 Proxy 向服务端发起远程过程调用，Proxy 负责将调用的方法、参数等数据转化为网络字节流；
4. 客户端从服务列表中根据负载均衡策略选择一个服务地址，并将数据通过网络发送给服务端；
5. 服务端得到数据后，调用对应的服务，然后将结果通过网络返回给客户端。

虽然 RPC 调用流程很容易理解，但是实现一个完整的 RPC 框架设计到很多内容，例如服务注册与发现、通信协议与序列化、负载均衡、动态代理等。

## 项目结构介绍

### 目录结构

```txt
planbRpc
├─core	--rpc核心实现类
├─Provider-api	--服务接口类
├─Consumer	--[示例]服务消费者
└─Provider	--[示例]服务提供者
```

### 核心模块结构

```

├── register                       -> 注册中心相关功能
├── model                          -> 模型数据存放
├── server                         -> 服务启动配置
├── retry                          -> 重试
├── tolerant                       -> 容错
├── protocol                         -> 自定义协议
├── loadbalance                    -> 负载均衡
└── serialization                  -> 序列化与反序列化
```

## 运行项目

1、首先需要安装并启动 etcd；

2、修改 Consumer 和 Provider 模块下的 application.properties 的注册中心地址属性，即 rpc.serverPort=你的etcd连接地址；

3、先启动 Provider 模块，正常启动 SpringBoot 项目即可。

4、然后启动 Consumer 模块，去访问服务进行 rpc 调用。

## 项目实现的主要内容

### 自定义消息协议，编解码

既然 RPC 是远程调用，必然离不开网络通信协议。客户端在向服务端发起调用之前，需要考虑采用何种方式将调用信息进行编码，并传输到服务端。因为 RPC 框架对性能有非常高的要求，所以通信协议应该越简单越好，这样可以减少编解码的性能损耗。RPC 框架可以基于不同的协议实现，大部分主流 RPC 框架会选择 TCP、HTTP 协议，出名的 gRPC 框架使用的则是 HTTP2。TCP、HTTP、HTTP2 都是稳定可靠的，但其实使用 UDP 协议也是可以的，具体看业务使用的场景。成熟的 RPC 框架能够支持多种协议，例如阿里开源的 Dubbo 框架被很多互联网公司广泛使用，其中可插拔的协议支持是 Dubbo 的一大特色，这样不仅可以给开发者提供多种不同的选择，而且为接入异构系统提供了便利。

#### 自定义消息协议

自定义协议的要数：

* 魔数，用来在第一时间判定是否是无效数据包
* 版本号，可以支持协议的升级
* 序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk、kryo
* 指令类型，是登录、注册、单聊、群聊... 跟业务相关
* 请求序号，为了双工通信，提供异步能力，通过这个请求ID将响应关联起来，也可以通过请求ID做链路追踪。
* 正文长度，标注传输数据内容的长度，用于判断是否是一个完整的数据包
* 消息正文，主要传递的消息内容

#### 编解码

##### 解决粘包半包

1、现象分析

- 本质是因为 TCP 是流式协议，消息无边界

2、解决方案

- 短连接：发一次数据包建立一次连接，这样连接建立到连接断开之间就是一次消息边界，缺点是效率低；
- 固定长度：每一条消息采用固定长度，缺点是浪费空间；
- 分隔符：每一条消息采用分隔符，例如 \n ，缺点是需要转义；
- 消息长度+消息内容：每一条消息分为 header 和 body，header 中包含 body 的长度（推荐）；

本项目采取的是 消息长度 + 消息内容 来解决的半包问题

在发送消息前，先约定用定长字节表示接下来数据的长度：

### 序列化算法

#### 概述

客户端和服务端在通信过程中需要传输哪些数据呢？这些数据又该如何编解码呢？如果采用 TCP 协议，你需要将调用的接口、方法、请求参数、调用属性等信息序列化成二进制字节流传递给服务提供方，服务端接收到数据后，再把二进制字节流反序列化得到调用信息，然后利用反射的原理调用对应方法，最后将返回结果、返回码、异常信息等返回给客户端。所谓序列化和反序列化就是将对象转换成二进制流以及将二进制流再转换成对象的过程。因为网络通信依赖于字节流，而且这些请求信息都是不确定的，所以一般会选用通用且高效的序列化算法。比较常用的序列化算法有 FastJson、Kryo、Hessian、Protobuf 等，这些第三方序列化算法都比 Java 原生的序列化操作都更加高效。Dubbo 支持多种序列化算法，并定义了 Serialization 接口规范，所有序列化算法扩展都必须实现该接口，其中默认使用的是 Hessian 序列化算法。

序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等同样也起着至关重要的作用，是我们提升分布式系统性能的最关键因素之一。


#### 实现

本项目实现了五种序列化算法，分别是：

**JDK、JSON、HESSIAN、KRYO 、PROTOSTUFF**

五种序列化算法的比较如下：

| 序列化算法          | **优点**         | **缺点**   |
|----------------|----------------|----------|
| **Kryo**       | 速度快，序列化后体积小    | 跨语言支持较复杂 |
| **Hessian**    | 默认支持跨语言        | 较慢       |
| **Protostuff** | 速度快，基于protobuf | 需静态编译    |
| **Json**       | 使用方便           | 性能一般     |
| **Jdk**        | 使用方便，可序列化所有类   | 速度慢，占空间  |


### 负载均衡算法

本项目实现了 Random、RoundRobin、ConsistentHash 三种负载均衡算法

在分布式系统中，服务提供者和服务消费者都会有多台节点，如何保证服务提供者所有节点的负载均衡呢？客户端在发起调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。客户端需要拿到服务端节点的状态信息，并根据不同的策略实现负载均衡算法。负载均衡策略是影响 RPC 框架吞吐量很重要的一个因素，下面我们介绍几种最常用的负载均衡策略。

- Round-Robin 轮询。Round-Robin 是最简单有效的负载均衡策略，并没有考虑服务端节点的实际负载水平，而是依次轮询服务端节点。
- Weighted Round-Robin 权重轮询。对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量。权重系数可以根据服务端负载水平实时进行调整，使集群达到相对均衡的状态。
- Least Connections 最少连接数。客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections 策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU 利用率最低等其他维度的负载均衡方案。
- Consistent Hash 一致性 Hash。目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点。

此外，负载均衡算法可以是多种多样的，客户端可以记录例如健康状态、连接数、内存、CPU、Load 等更加丰富的信息，根据综合因素进行更好地决策。

### 服务注册与发现

在分布式系统中，不同服务之间应该如何通信呢？传统的方式可以通过 HTTP 请求调用、保存服务端的服务列表等，这样做需要开发者主动感知到服务端暴露的信息，系统之间耦合严重。为了更好地将客户端和服务端解耦，以及实现服务优雅上线和下线，于是注册中心就出现了。

在 RPC 框架中，主要是使用注册中心来实现服务注册和发现的功能。服务端节点上线后自行向注册中心注册服务列表，节点下线时需要从注册中心将节点元数据信息移除。客户端向服务端发起调用时，自己负责从注册中心获取服务端的服务列表，然后在通过负载均衡算法选择其中一个服务节点进行调用。以上是最简单直接的服务端和客户端的发布和订阅模式，不需要再借助任何中间服务器，性能损耗也是最小的。

现在思考一个问题，服务在下线时需要从注册中心移除元数据，那么注册中心怎么才能感知到服务下线呢？我们最先想到的方法就是节点主动通知的实现方式，当节点需要下线时，向注册中心发送下线请求，让注册中心移除自己的元数据信息。但是如果节点异常退出，例如断网、进程崩溃等，那么注册中心将会一直残留异常节点的元数据，从而可能造成服务调用出现问题。

为了避免上述问题，实现服务优雅下线比较好的方式是采用主动通知 + 心跳检测的方案。除了主动通知注册中心下线外，还需要增加节点与注册中心的心跳检测功能，这个过程也叫作探活。心跳检测可以由节点或者注册中心负责，例如注册中心可以向服务节点每 60s 发送一次心跳包，如果 3 次心跳包都没有收到请求结果，可以认为该服务节点已经下线。

由此可见，采用注册中心的好处是可以解耦客户端和服务端之间错综复杂的关系，并且能够实现对服务的动态管理。服务配置可以支持动态修改，然后将更新后的配置推送到客户端和服务端，无须重启任何服务。

本项目目前实现了以 Etcd 为注册中心。


### 增加 Etcd 服务本地缓存并监听

解决了每次请求都需要访问 etcd 来进行服务发现，可以添加本地服务缓存功能，然后监听 ectd 服务节点的变化来动态更新本地服务列表。


### 实现了 SPI 机制

已实现，参考Dubbo部分源码，实现了自定义的SPI机制，目前仅支持根据接口类型加载配置文件中的所有具体的扩展实现类，并且可以根据指定的key获取特定的实现类。
